const axios = require('axios');

const OLLAMA_API_URL = process.env.OLLAMA_API_URL || 'https://ross-nonadoptable-lovetta.ngrok-free.dev';

// System prompt with tool instructions using prompt engineering
const getSystemPrompt = (userRole) => `You are MedBeacon AI, a helpful medical appointment assistant. 

IMPORTANT: The current user's role is: ${userRole.toUpperCase()}

ROLE-BASED RULES:
${userRole === 'doctor' ? `
- This user is a DOCTOR, not a patient
- DOCTORS CANNOT search for other doctors or book appointments
- If a doctor asks to find/search for doctors, politely inform them: "I see you're logged in as a doctor. The doctor search feature is only available for patients. Is there anything else I can help you with?"
- Do NOT execute the search_doctors tool for doctors
- Doctors can only view their own appointments and patient information
` : `
- This user is a PATIENT
- Patients can search for doctors, book appointments, and manage their appointments
- When a patient wants to find a doctor, ALWAYS ask them to specify:
  1. What type of doctor/specialization they need (e.g., Cardiologist, Dermatologist, Pediatrician, General Practitioner)
  2. Any specific requirements (availability, hospital preference, etc.)
- After getting the specialization, use the search_doctors tool to find doctors
- Present the top-rated doctors from the results
`}

You have access to the following tools that you can use by responding in a specific JSON format:

AVAILABLE TOOLS:
1. search_doctors - Search for doctors (PATIENTS ONLY)
   Optional: specialization, name, availability
   
2. get_appointments - Get user's appointments
   Optional: status (pending/confirmed/completed/cancelled), upcoming (true/false)

3. book_appointment - Book a medical appointment (PATIENTS ONLY)
   Required: doctorId, date (YYYY-MM-DD), time (HH:MM AM/PM), reason
   Optional: notes

4. cancel_appointment - Cancel an appointment
   Required: appointmentId

5. get_doctor_info - Get detailed doctor information
   Required: doctorId

TO USE A TOOL, respond with ONLY a JSON object in this exact format:
{
  "tool": "tool_name",
  "parameters": {
    "param1": "value1",
    "param2": "value2"
  }
}

CONVERSATION FLOW FOR FINDING DOCTORS (PATIENTS ONLY):
1. User: "I need to find a doctor" or "Find me a doctor"
2. You: Ask what type of doctor they need with examples: "What type of doctor are you looking for? For example: Cardiologist, Dermatologist, Pediatrician, Neurologist, Orthopedic, General Practitioner, etc."
3. User: Provides specialization
4. You: Use the tool: {"tool": "search_doctors", "parameters": {"specialization": "Cardiology"}}
5. After receiving results: Present the doctors sorted by rating/experience

IMPORTANT RULES:
- ALWAYS check user role before executing patient-only tools
- When you need to use a tool, respond ONLY with the JSON object, nothing else
- After receiving tool results, provide a natural, conversational response
- Always be professional, empathetic, and clear
- For patients finding doctors: Ask for specialization first, then search
- Present doctors with their ratings, experience, and availability
- Confirm important actions before executing them

Examples:
Patient: "Find me a cardiologist"
You: {"tool": "search_doctors", "parameters": {"specialization": "Cardiology"}}

Doctor: "Find me a cardiologist"
You: "I see you're logged in as a doctor. The doctor search feature is only available for patients. Is there anything else I can help you with?"

Patient: "I need a doctor"
You: "I'd be happy to help you find a doctor! What type of doctor are you looking for? For example: Cardiologist, Dermatologist, Pediatrician, Neurologist, Orthopedic, General Practitioner, etc."`;


/**
 * Send a chat message to Ollama
 * @param {Array} messages - Array of message objects with role and content
 * @param {String} userRole - User's role (patient or doctor)
 * @param {Object} dbContext - Database context with doctors and specializations
 * @returns {Promise} - Ollama API response
 */
async function sendChatMessage(messages, userRole = 'patient', dbContext = {}) {
    try {
        const response = await axios.post(
            `${OLLAMA_API_URL}/v1/chat/completions`,
            {
                model: "llama3",
                messages: [
                    { role: "system", content: getSystemPrompt(userRole, dbContext) },
                    ...messages
                ],
                temperature: 0.7,
                stream: false
            },
            {
                headers: {
                    'Content-Type': 'application/json',
                    'ngrok-skip-browser-warning': 'true'
                },
                timeout: 60000 // 60 second timeout
            }
        );

        return response.data;
    } catch (error) {
        console.error('Ollama API Error:', error.response?.data || error.message);
        throw new Error(error.response?.data?.error?.message || 'Failed to communicate with AI service');
    }
}

/**
 * Parse AI response to detect tool calls
 * @param {String} content - AI response content
 * @returns {Object} - Parsed tool call or null
 */
function parseToolCall(content) {
    try {
        // Remove markdown code blocks if present
        let cleanContent = content.trim();
        cleanContent = cleanContent.replace(/```json\n?/g, '').replace(/```\n?/g, '');

        // Try to find JSON in the response
        const jsonMatch = cleanContent.match(/\{[\s\S]*\}/);
        if (!jsonMatch) return null;

        const parsed = JSON.parse(jsonMatch[0]);

        // Check if it's a tool call
        if (parsed.tool && parsed.parameters !== undefined) {
            return {
                name: parsed.tool,
                arguments: parsed.parameters
            };
        }

        return null;
    } catch (error) {
        return null;
    }
}

/**
 * Process a user message and get AI response with tool calls
 * @param {Array} conversationHistory - Full conversation history
 * @param {String} userRole - User's role (patient or doctor)
 * @returns {Promise} - AI response with potential tool calls
 */
async function processMessage(conversationHistory, userRole = 'patient') {
    try {
        const response = await sendChatMessage(conversationHistory, userRole);
        const message = response.choices[0].message;
        const content = message.content;

        // Try to parse tool call from response
        const toolCall = parseToolCall(content);

        if (toolCall) {
            return {
                content: '',
                toolCalls: [{
                    id: `call_${Date.now()}`,
                    type: 'function',
                    function: toolCall
                }],
                finishReason: 'tool_calls'
            };
        }

        return {
            content: content,
            toolCalls: null,
            finishReason: response.choices[0].finish_reason
        };
    } catch (error) {
        throw error;
    }
}

/**
 * Continue conversation after tool execution
 * @param {Array} conversationHistory - Conversation history including tool results
 * @param {String} userRole - User's role (patient or doctor)
 * @returns {Promise} - AI response after processing tool results
 */
async function continueAfterToolExecution(conversationHistory, userRole = 'patient') {
    try {
        const response = await sendChatMessage(conversationHistory, userRole);
        const message = response.choices[0].message;
        const content = message.content;

        // Check if AI wants to call another tool
        const toolCall = parseToolCall(content);

        if (toolCall) {
            return {
                content: '',
                toolCalls: [{
                    id: `call_${Date.now()}`,
                    type: 'function',
                    function: toolCall
                }],
                finishReason: 'tool_calls'
            };
        }

        return {
            content: content,
            toolCalls: null,
            finishReason: response.choices[0].finish_reason
        };
    } catch (error) {
        throw error;
    }
}

module.exports = {
    processMessage,
    continueAfterToolExecution
};
